/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.1.0 (NJsonSchema v10.3.3.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    cargoAll(): Observable<CargosRequestDTO[]> {
        let url_ = this.baseUrl + "/api/Cargo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCargoAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCargoAll(<any>response_);
                } catch (e) {
                    return <Observable<CargosRequestDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargosRequestDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processCargoAll(response: HttpResponseBase): Observable<CargosRequestDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CargosRequestDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargosRequestDTO[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    cargo(body: CargosBase | undefined): Observable<CargosBase> {
        let url_ = this.baseUrl + "/api/Cargo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCargo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCargo(<any>response_);
                } catch (e) {
                    return <Observable<CargosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargosBase>><any>_observableThrow(response_);
        }));
    }

    protected processCargo(response: HttpResponseBase): Observable<CargosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargosBase>(<any>null);
    }

    /**
     * @return Success
     */
    obtenerCargo(id: number): Observable<CargosBase> {
        let url_ = this.baseUrl + "/api/Cargo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCargo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCargo(<any>response_);
                } catch (e) {
                    return <Observable<CargosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargosBase>><any>_observableThrow(response_);
        }));
    }

    protected processObtenerCargo(response: HttpResponseBase): Observable<CargosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargosBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    cargo2(id: number, body: CargosUpdateRequestDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Cargo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCargo2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCargo2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCargo2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    cargo3(id: number, body: CargosBase | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Cargo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCargo3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCargo3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCargo3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    cargo4(id: number): Observable<CargosBase> {
        let url_ = this.baseUrl + "/api/Cargo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCargo4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCargo4(<any>response_);
                } catch (e) {
                    return <Observable<CargosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargosBase>><any>_observableThrow(response_);
        }));
    }

    protected processCargo4(response: HttpResponseBase): Observable<CargosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargosBase>(<any>null);
    }

    /**
     * @return Success
     */
    categoriaAll(): Observable<CategoriasRequestDTO[]> {
        let url_ = this.baseUrl + "/api/Categoria";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriaAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriaAll(<any>response_);
                } catch (e) {
                    return <Observable<CategoriasRequestDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoriasRequestDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processCategoriaAll(response: HttpResponseBase): Observable<CategoriasRequestDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoriasRequestDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoriasRequestDTO[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    categoria(body: CategoriasBase | undefined): Observable<CategoriasBase> {
        let url_ = this.baseUrl + "/api/Categoria";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoria(<any>response_);
                } catch (e) {
                    return <Observable<CategoriasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoriasBase>><any>_observableThrow(response_);
        }));
    }

    protected processCategoria(response: HttpResponseBase): Observable<CategoriasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoriasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoriasBase>(<any>null);
    }

    /**
     * @return Success
     */
    obtenerCategoria(id: number): Observable<CategoriasBase> {
        let url_ = this.baseUrl + "/api/Categoria/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCategoria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCategoria(<any>response_);
                } catch (e) {
                    return <Observable<CategoriasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoriasBase>><any>_observableThrow(response_);
        }));
    }

    protected processObtenerCategoria(response: HttpResponseBase): Observable<CategoriasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoriasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoriasBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    categoria2(id: number, body: CategoriasUpdateRequestDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Categoria/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoria2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoria2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCategoria2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    categoria3(id: number, body: CategoriasBase | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Categoria/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoria3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoria3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCategoria3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    categoria4(id: number): Observable<CategoriasBase> {
        let url_ = this.baseUrl + "/api/Categoria/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoria4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoria4(<any>response_);
                } catch (e) {
                    return <Observable<CategoriasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoriasBase>><any>_observableThrow(response_);
        }));
    }

    protected processCategoria4(response: HttpResponseBase): Observable<CategoriasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoriasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoriasBase>(<any>null);
    }

    /**
     * @return Success
     */
    clienteAll(): Observable<ClientesRequestDTO[]> {
        let url_ = this.baseUrl + "/api/Cliente";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClienteAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClienteAll(<any>response_);
                } catch (e) {
                    return <Observable<ClientesRequestDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientesRequestDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processClienteAll(response: HttpResponseBase): Observable<ClientesRequestDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientesRequestDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientesRequestDTO[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    cliente(body: ClientesBase | undefined): Observable<ClientesBase> {
        let url_ = this.baseUrl + "/api/Cliente";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCliente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCliente(<any>response_);
                } catch (e) {
                    return <Observable<ClientesBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientesBase>><any>_observableThrow(response_);
        }));
    }

    protected processCliente(response: HttpResponseBase): Observable<ClientesBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientesBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientesBase>(<any>null);
    }

    /**
     * @return Success
     */
    obtenerCliente(id: number): Observable<ClientesBase> {
        let url_ = this.baseUrl + "/api/Cliente/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerCliente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerCliente(<any>response_);
                } catch (e) {
                    return <Observable<ClientesBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientesBase>><any>_observableThrow(response_);
        }));
    }

    protected processObtenerCliente(response: HttpResponseBase): Observable<ClientesBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientesBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientesBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    cliente2(id: any, body: ClientesUpdateRequestDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Cliente/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCliente2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCliente2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCliente2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    cliente3(id: number, body: ClientesBase | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Cliente/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCliente3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCliente3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCliente3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    cliente4(id: any): Observable<ClientesBase> {
        let url_ = this.baseUrl + "/api/Cliente/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCliente4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCliente4(<any>response_);
                } catch (e) {
                    return <Observable<ClientesBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientesBase>><any>_observableThrow(response_);
        }));
    }

    protected processCliente4(response: HttpResponseBase): Observable<ClientesBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientesBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientesBase>(<any>null);
    }

    /**
     * @return Success
     */
    empleadoAll(): Observable<EmpleadosRequestDTO[]> {
        let url_ = this.baseUrl + "/api/Empleado";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpleadoAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpleadoAll(<any>response_);
                } catch (e) {
                    return <Observable<EmpleadosRequestDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpleadosRequestDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processEmpleadoAll(response: HttpResponseBase): Observable<EmpleadosRequestDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmpleadosRequestDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpleadosRequestDTO[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    empleado(body: EmpleadosBase | undefined): Observable<EmpleadosBase> {
        let url_ = this.baseUrl + "/api/Empleado";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpleado(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpleado(<any>response_);
                } catch (e) {
                    return <Observable<EmpleadosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpleadosBase>><any>_observableThrow(response_);
        }));
    }

    protected processEmpleado(response: HttpResponseBase): Observable<EmpleadosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpleadosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpleadosBase>(<any>null);
    }

    /**
     * @return Success
     */
    obtenerEmpleado(id: number): Observable<EmpleadosBase> {
        let url_ = this.baseUrl + "/api/Empleado/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEmpleado(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEmpleado(<any>response_);
                } catch (e) {
                    return <Observable<EmpleadosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpleadosBase>><any>_observableThrow(response_);
        }));
    }

    protected processObtenerEmpleado(response: HttpResponseBase): Observable<EmpleadosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpleadosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpleadosBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    empleado2(id: any, body: EmpleadosUpdateRequestDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Empleado/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpleado2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpleado2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEmpleado2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    empleado3(id: number, body: EmpleadosBase | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Empleado/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpleado3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpleado3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEmpleado3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    empleado4(id: any): Observable<EmpleadosBase> {
        let url_ = this.baseUrl + "/api/Empleado/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpleado4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpleado4(<any>response_);
                } catch (e) {
                    return <Observable<EmpleadosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpleadosBase>><any>_observableThrow(response_);
        }));
    }

    protected processEmpleado4(response: HttpResponseBase): Observable<EmpleadosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpleadosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpleadosBase>(<any>null);
    }

    /**
     * @return Success
     */
    empresaAll(): Observable<EmpresasRequestDTO[]> {
        let url_ = this.baseUrl + "/api/Empresa";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpresaAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpresaAll(<any>response_);
                } catch (e) {
                    return <Observable<EmpresasRequestDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpresasRequestDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processEmpresaAll(response: HttpResponseBase): Observable<EmpresasRequestDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmpresasRequestDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpresasRequestDTO[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    empresa(body: EmpresasBase | undefined): Observable<EmpresasBase> {
        let url_ = this.baseUrl + "/api/Empresa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpresa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpresa(<any>response_);
                } catch (e) {
                    return <Observable<EmpresasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpresasBase>><any>_observableThrow(response_);
        }));
    }

    protected processEmpresa(response: HttpResponseBase): Observable<EmpresasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpresasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpresasBase>(<any>null);
    }

    /**
     * @return Success
     */
    obtenerEmpresa(id: number): Observable<EmpresasBase> {
        let url_ = this.baseUrl + "/api/Empresa/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerEmpresa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerEmpresa(<any>response_);
                } catch (e) {
                    return <Observable<EmpresasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpresasBase>><any>_observableThrow(response_);
        }));
    }

    protected processObtenerEmpresa(response: HttpResponseBase): Observable<EmpresasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpresasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpresasBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    empresa2(id: any, body: EmpresasUpdateRequestDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Empresa/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpresa2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpresa2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEmpresa2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    empresa3(id: number, body: EmpresasBase | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Empresa/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpresa3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpresa3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEmpresa3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    empresa4(id: any): Observable<EmpresasBase> {
        let url_ = this.baseUrl + "/api/Empresa/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmpresa4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmpresa4(<any>response_);
                } catch (e) {
                    return <Observable<EmpresasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpresasBase>><any>_observableThrow(response_);
        }));
    }

    protected processEmpresa4(response: HttpResponseBase): Observable<EmpresasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpresasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpresasBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    creacionDetalleFactura(body: FacturasBase | undefined): Observable<FacturasBase> {
        let url_ = this.baseUrl + "/Api/Factura/Creacion-Detalle-Factura";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreacionDetalleFactura(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreacionDetalleFactura(<any>response_);
                } catch (e) {
                    return <Observable<FacturasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacturasBase>><any>_observableThrow(response_);
        }));
    }

    protected processCreacionDetalleFactura(response: HttpResponseBase): Observable<FacturasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacturasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacturasBase>(<any>null);
    }

    /**
     * @return Success
     */
    facturaAll(): Observable<FacturasRequestsDTO[]> {
        let url_ = this.baseUrl + "/Api/Factura";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFacturaAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFacturaAll(<any>response_);
                } catch (e) {
                    return <Observable<FacturasRequestsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacturasRequestsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processFacturaAll(response: HttpResponseBase): Observable<FacturasRequestsDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FacturasRequestsDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacturasRequestsDTO[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    factura(body: FacturasBase | undefined): Observable<FacturasBase> {
        let url_ = this.baseUrl + "/Api/Factura";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFactura(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFactura(<any>response_);
                } catch (e) {
                    return <Observable<FacturasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacturasBase>><any>_observableThrow(response_);
        }));
    }

    protected processFactura(response: HttpResponseBase): Observable<FacturasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacturasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacturasBase>(<any>null);
    }

    /**
     * @return Success
     */
    obtenerFactura(id: number): Observable<FacturasBase> {
        let url_ = this.baseUrl + "/Api/Factura/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerFactura(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerFactura(<any>response_);
                } catch (e) {
                    return <Observable<FacturasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacturasBase>><any>_observableThrow(response_);
        }));
    }

    protected processObtenerFactura(response: HttpResponseBase): Observable<FacturasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacturasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacturasBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    factura2(id: number, body: FacturasUpdateRequestDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Api/Factura/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFactura2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFactura2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFactura2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    factura3(id: number, body: FacturasBase | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Api/Factura/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFactura3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFactura3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFactura3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    factura4(id: any): Observable<FacturasBase> {
        let url_ = this.baseUrl + "/Api/Factura/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFactura4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFactura4(<any>response_);
                } catch (e) {
                    return <Observable<FacturasBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacturasBase>><any>_observableThrow(response_);
        }));
    }

    protected processFactura4(response: HttpResponseBase): Observable<FacturasBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacturasBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacturasBase>(<any>null);
    }

    /**
     * @return Success
     */
    facturasProductos(): Observable<FacturasProductosRequestDTO> {
        let url_ = this.baseUrl + "/api/FacturasProductos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFacturasProductos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFacturasProductos(<any>response_);
                } catch (e) {
                    return <Observable<FacturasProductosRequestDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacturasProductosRequestDTO>><any>_observableThrow(response_);
        }));
    }

    protected processFacturasProductos(response: HttpResponseBase): Observable<FacturasProductosRequestDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacturasProductosRequestDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacturasProductosRequestDTO>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    facturasProductos2(body: FacturasProductosBase | undefined): Observable<FacturasProductosBase> {
        let url_ = this.baseUrl + "/api/FacturasProductos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFacturasProductos2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFacturasProductos2(<any>response_);
                } catch (e) {
                    return <Observable<FacturasProductosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacturasProductosBase>><any>_observableThrow(response_);
        }));
    }

    protected processFacturasProductos2(response: HttpResponseBase): Observable<FacturasProductosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacturasProductosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacturasProductosBase>(<any>null);
    }

    /**
     * @return Success
     */
    obtenerFacturasProductos(id: number): Observable<FacturasProductosBase> {
        let url_ = this.baseUrl + "/api/FacturasProductos/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerFacturasProductos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerFacturasProductos(<any>response_);
                } catch (e) {
                    return <Observable<FacturasProductosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacturasProductosBase>><any>_observableThrow(response_);
        }));
    }

    protected processObtenerFacturasProductos(response: HttpResponseBase): Observable<FacturasProductosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacturasProductosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacturasProductosBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    facturasProductos3(id: number, body: FacturasProductosUpdateRequestDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FacturasProductos/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFacturasProductos3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFacturasProductos3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFacturasProductos3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    facturasProductos4(id: number, body: FacturasProductosBase | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FacturasProductos/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFacturasProductos4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFacturasProductos4(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFacturasProductos4(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    facturasProductos5(id: any): Observable<FacturasProductosBase> {
        let url_ = this.baseUrl + "/api/FacturasProductos/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFacturasProductos5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFacturasProductos5(<any>response_);
                } catch (e) {
                    return <Observable<FacturasProductosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<FacturasProductosBase>><any>_observableThrow(response_);
        }));
    }

    protected processFacturasProductos5(response: HttpResponseBase): Observable<FacturasProductosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacturasProductosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacturasProductosBase>(<any>null);
    }

    /**
     * @return Success
     */
    productoAll(): Observable<ProductosRequestDTO[]> {
        let url_ = this.baseUrl + "/api/Producto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductoAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductoAll(<any>response_);
                } catch (e) {
                    return <Observable<ProductosRequestDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductosRequestDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processProductoAll(response: HttpResponseBase): Observable<ProductosRequestDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductosRequestDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductosRequestDTO[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    producto(body: ProductosBase | undefined): Observable<ProductosBase> {
        let url_ = this.baseUrl + "/api/Producto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProducto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProducto(<any>response_);
                } catch (e) {
                    return <Observable<ProductosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductosBase>><any>_observableThrow(response_);
        }));
    }

    protected processProducto(response: HttpResponseBase): Observable<ProductosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductosBase>(<any>null);
    }

    /**
     * @return Success
     */
    obtenerProducto(id: number): Observable<ProductosBase> {
        let url_ = this.baseUrl + "/api/Producto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerProducto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerProducto(<any>response_);
                } catch (e) {
                    return <Observable<ProductosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductosBase>><any>_observableThrow(response_);
        }));
    }

    protected processObtenerProducto(response: HttpResponseBase): Observable<ProductosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductosBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    producto2(id: any, body: ProductosUpdateRequestDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Producto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProducto2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProducto2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProducto2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    producto3(id: number, body: ProductosBase | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Producto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProducto3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProducto3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProducto3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    producto4(id: any): Observable<ProductosBase> {
        let url_ = this.baseUrl + "/api/Producto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProducto4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProducto4(<any>response_);
                } catch (e) {
                    return <Observable<ProductosBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductosBase>><any>_observableThrow(response_);
        }));
    }

    protected processProducto4(response: HttpResponseBase): Observable<ProductosBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductosBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductosBase>(<any>null);
    }

    /**
     * @return Success
     */
    tipoClienteAll(): Observable<TipoClientesRequestDTO[]> {
        let url_ = this.baseUrl + "/api/TipoCliente";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTipoClienteAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTipoClienteAll(<any>response_);
                } catch (e) {
                    return <Observable<TipoClientesRequestDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TipoClientesRequestDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processTipoClienteAll(response: HttpResponseBase): Observable<TipoClientesRequestDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoClientesRequestDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TipoClientesRequestDTO[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    tipoCliente(body: TipoClientesBase | undefined): Observable<TipoClientesBase> {
        let url_ = this.baseUrl + "/api/TipoCliente";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTipoCliente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTipoCliente(<any>response_);
                } catch (e) {
                    return <Observable<TipoClientesBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<TipoClientesBase>><any>_observableThrow(response_);
        }));
    }

    protected processTipoCliente(response: HttpResponseBase): Observable<TipoClientesBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoClientesBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TipoClientesBase>(<any>null);
    }

    /**
     * @return Success
     */
    obtenerTipoCliente(id: number): Observable<TipoClientesBase> {
        let url_ = this.baseUrl + "/api/TipoCliente/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerTipoCliente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerTipoCliente(<any>response_);
                } catch (e) {
                    return <Observable<TipoClientesBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<TipoClientesBase>><any>_observableThrow(response_);
        }));
    }

    protected processObtenerTipoCliente(response: HttpResponseBase): Observable<TipoClientesBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoClientesBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TipoClientesBase>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    tipoCliente2(id: number, body: TipoClientesUpdateRequestDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TipoCliente/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTipoCliente2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTipoCliente2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTipoCliente2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    tipoCliente3(id: number, body: TipoClientesBase | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TipoCliente/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTipoCliente3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTipoCliente3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTipoCliente3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    tipoCliente4(id: number): Observable<TipoClientesBase> {
        let url_ = this.baseUrl + "/api/TipoCliente/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTipoCliente4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTipoCliente4(<any>response_);
                } catch (e) {
                    return <Observable<TipoClientesBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<TipoClientesBase>><any>_observableThrow(response_);
        }));
    }

    protected processTipoCliente4(response: HttpResponseBase): Observable<TipoClientesBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoClientesBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TipoClientesBase>(<any>null);
    }

    /**
     * @return Success
     */
    weatherForecast(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherForecast(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processWeatherForecast(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export class CargosRequestDTO implements ICargosRequestDTO {
    nombre?: string | undefined;
    empleadoId?: number | undefined;
    id?: number;

    constructor(data?: ICargosRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.empleadoId = _data["empleadoId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CargosRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CargosRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["empleadoId"] = this.empleadoId;
        data["id"] = this.id;
        return data;
    }

    clone(): CargosRequestDTO {
        const json = this.toJSON();
        let result = new CargosRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ICargosRequestDTO {
    nombre?: string | undefined;
    empleadoId?: number | undefined;
    id?: number;
}

export class CargosBase implements ICargosBase {
    nombre?: string | undefined;
    empleadoId?: number | undefined;

    constructor(data?: ICargosBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.empleadoId = _data["empleadoId"];
        }
    }

    static fromJS(data: any): CargosBase {
        data = typeof data === 'object' ? data : {};
        let result = new CargosBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["empleadoId"] = this.empleadoId;
        return data;
    }

    clone(): CargosBase {
        const json = this.toJSON();
        let result = new CargosBase();
        result.init(json);
        return result;
    }
}

export interface ICargosBase {
    nombre?: string | undefined;
    empleadoId?: number | undefined;
}

export class CargosUpdateRequestDTO implements ICargosUpdateRequestDTO {
    nombre?: string | undefined;
    empleadoId?: number | undefined;

    constructor(data?: ICargosUpdateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.empleadoId = _data["empleadoId"];
        }
    }

    static fromJS(data: any): CargosUpdateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CargosUpdateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["empleadoId"] = this.empleadoId;
        return data;
    }

    clone(): CargosUpdateRequestDTO {
        const json = this.toJSON();
        let result = new CargosUpdateRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ICargosUpdateRequestDTO {
    nombre?: string | undefined;
    empleadoId?: number | undefined;
}

export class CategoriasRequestDTO implements ICategoriasRequestDTO {
    nombre?: string | undefined;
    descripcion?: string | undefined;
    id?: number;

    constructor(data?: ICategoriasRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CategoriasRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoriasRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        data["id"] = this.id;
        return data;
    }

    clone(): CategoriasRequestDTO {
        const json = this.toJSON();
        let result = new CategoriasRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ICategoriasRequestDTO {
    nombre?: string | undefined;
    descripcion?: string | undefined;
    id?: number;
}

export class CategoriasBase implements ICategoriasBase {
    nombre?: string | undefined;
    descripcion?: string | undefined;

    constructor(data?: ICategoriasBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
        }
    }

    static fromJS(data: any): CategoriasBase {
        data = typeof data === 'object' ? data : {};
        let result = new CategoriasBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        return data;
    }

    clone(): CategoriasBase {
        const json = this.toJSON();
        let result = new CategoriasBase();
        result.init(json);
        return result;
    }
}

export interface ICategoriasBase {
    nombre?: string | undefined;
    descripcion?: string | undefined;
}

export class CategoriasUpdateRequestDTO implements ICategoriasUpdateRequestDTO {
    nombre?: string | undefined;
    descripcion?: string | undefined;

    constructor(data?: ICategoriasUpdateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
        }
    }

    static fromJS(data: any): CategoriasUpdateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoriasUpdateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        return data;
    }

    clone(): CategoriasUpdateRequestDTO {
        const json = this.toJSON();
        let result = new CategoriasUpdateRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ICategoriasUpdateRequestDTO {
    nombre?: string | undefined;
    descripcion?: string | undefined;
}

export class ClientesRequestDTO implements IClientesRequestDTO {
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    id?: number;

    constructor(data?: IClientesRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.apellido = _data["apellido"];
            this.direccion = _data["direccion"];
            this.telefono = _data["telefono"];
            this.email = _data["email"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientesRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClientesRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["apellido"] = this.apellido;
        data["direccion"] = this.direccion;
        data["telefono"] = this.telefono;
        data["email"] = this.email;
        data["id"] = this.id;
        return data;
    }

    clone(): ClientesRequestDTO {
        const json = this.toJSON();
        let result = new ClientesRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IClientesRequestDTO {
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    id?: number;
}

export class ClientesBase implements IClientesBase {
    id?: number;
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;

    constructor(data?: IClientesBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nombre = _data["nombre"];
            this.apellido = _data["apellido"];
            this.direccion = _data["direccion"];
            this.telefono = _data["telefono"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ClientesBase {
        data = typeof data === 'object' ? data : {};
        let result = new ClientesBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["apellido"] = this.apellido;
        data["direccion"] = this.direccion;
        data["telefono"] = this.telefono;
        data["email"] = this.email;
        return data;
    }

    clone(): ClientesBase {
        const json = this.toJSON();
        let result = new ClientesBase();
        result.init(json);
        return result;
    }
}

export interface IClientesBase {
    id?: number;
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
}

export class ClientesUpdateRequestDTO implements IClientesUpdateRequestDTO {
    id?: number;
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;

    constructor(data?: IClientesUpdateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["nombre"];
            this.nombre = _data["nombre"];
            this.apellido = _data["apellido"];
            this.direccion = _data["direccion"];
            this.telefono = _data["telefono"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ClientesUpdateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClientesUpdateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["apellido"] = this.apellido;
        data["direccion"] = this.direccion;
        data["telefono"] = this.telefono;
        data["email"] = this.email;
        return data;
    }

    clone(): ClientesUpdateRequestDTO {
        const json = this.toJSON();
        let result = new ClientesUpdateRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IClientesUpdateRequestDTO {
    id?: number;
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
}

export class EmpleadosRequestDTO implements IEmpleadosRequestDTO {
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    usuario?: string | undefined;
    contrasena?: string | undefined;
    empresaId?: number | undefined;
    id?: number;

    constructor(data?: IEmpleadosRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.apellido = _data["apellido"];
            this.direccion = _data["direccion"];
            this.telefono = _data["telefono"];
            this.usuario = _data["usuario"];
            this.contrasena = _data["contrasena"];
            this.empresaId = _data["empresaId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EmpleadosRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmpleadosRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["apellido"] = this.apellido;
        data["direccion"] = this.direccion;
        data["telefono"] = this.telefono;
        data["usuario"] = this.usuario;
        data["contrasena"] = this.contrasena;
        data["empresaId"] = this.empresaId;
        data["id"] = this.id;
        return data;
    }

    clone(): EmpleadosRequestDTO {
        const json = this.toJSON();
        let result = new EmpleadosRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IEmpleadosRequestDTO {
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    usuario?: string | undefined;
    contrasena?: string | undefined;
    empresaId?: number | undefined;
    id?: number;
}

export class EmpleadosBase implements IEmpleadosBase {
    id?: number;
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    usuario?: string | undefined;
    contrasena?: string | undefined;
    empresaId?: number | undefined;

    constructor(data?: IEmpleadosBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nombre = _data["nombre"];
            this.apellido = _data["apellido"];
            this.direccion = _data["direccion"];
            this.telefono = _data["telefono"];
            this.usuario = _data["usuario"];
            this.contrasena = _data["contrasena"];
            this.empresaId = _data["empresaId"];
        }
    }

    static fromJS(data: any): EmpleadosBase {
        data = typeof data === 'object' ? data : {};
        let result = new EmpleadosBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["apellido"] = this.apellido;
        data["direccion"] = this.direccion;
        data["telefono"] = this.telefono;
        data["usuario"] = this.usuario;
        data["contrasena"] = this.contrasena;
        data["empresaId"] = this.empresaId;
        return data;
    }

    clone(): EmpleadosBase {
        const json = this.toJSON();
        let result = new EmpleadosBase();
        result.init(json);
        return result;
    }
}

export interface IEmpleadosBase {
    id?: number;
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    usuario?: string | undefined;
    contrasena?: string | undefined;
    empresaId?: number | undefined;
}

export class EmpleadosUpdateRequestDTO implements IEmpleadosUpdateRequestDTO {
    id?: number;
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    usuario?: string | undefined;
    contrasena?: string | undefined;
    empresaId?: number | undefined;

    constructor(data?: IEmpleadosUpdateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nombre = _data["nombre"];
            this.apellido = _data["apellido"];
            this.direccion = _data["direccion"];
            this.telefono = _data["telefono"];
            this.usuario = _data["usuario"];
            this.contrasena = _data["contrasena"];
            this.empresaId = _data["empresaId"];
        }
    }

    static fromJS(data: any): EmpleadosUpdateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmpleadosUpdateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["apellido"] = this.apellido;
        data["direccion"] = this.direccion;
        data["telefono"] = this.telefono;
        data["usuario"] = this.usuario;
        data["contrasena"] = this.contrasena;
        data["empresaId"] = this.empresaId;
        return data;
    }

    clone(): EmpleadosUpdateRequestDTO {
        const json = this.toJSON();
        let result = new EmpleadosUpdateRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IEmpleadosUpdateRequestDTO {
    id?: number;
    nombre?: string | undefined;
    apellido?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    usuario?: string | undefined;
    contrasena?: string | undefined;
    empresaId?: number | undefined;
}

export class EmpresasRequestDTO implements IEmpresasRequestDTO {
    nombre?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    propietario?: string | undefined;
    email?: string | undefined;
    nit?: string | undefined;
    empleados?: EmpleadosRequestDTO[] | undefined;
    id?: number;

    constructor(data?: IEmpresasRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.direccion = _data["direccion"];
            this.telefono = _data["telefono"];
            this.propietario = _data["propietario"];
            this.email = _data["email"];
            this.nit = _data["nit"];
            if (Array.isArray(_data["empleados"])) {
                this.empleados = [] as any;
                for (let item of _data["empleados"])
                    this.empleados!.push(EmpleadosRequestDTO.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EmpresasRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmpresasRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["direccion"] = this.direccion;
        data["telefono"] = this.telefono;
        data["propietario"] = this.propietario;
        data["email"] = this.email;
        data["nit"] = this.nit;
        if (Array.isArray(this.empleados)) {
            data["empleados"] = [];
            for (let item of this.empleados)
                data["empleados"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): EmpresasRequestDTO {
        const json = this.toJSON();
        let result = new EmpresasRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IEmpresasRequestDTO {
    nombre?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    propietario?: string | undefined;
    email?: string | undefined;
    nit?: string | undefined;
    empleados?: EmpleadosRequestDTO[] | undefined;
    id?: number;
}

export class EmpresasBase implements IEmpresasBase {
    id?: number;
    nombre?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    propietario?: string | undefined;
    email?: string | undefined;
    nit?: string | undefined;
    empleados?: EmpleadosRequestDTO[] | undefined;

    constructor(data?: IEmpresasBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nombre = _data["nombre"];
            this.direccion = _data["direccion"];
            this.telefono = _data["telefono"];
            this.propietario = _data["propietario"];
            this.email = _data["email"];
            this.nit = _data["nit"];
            if (Array.isArray(_data["empleados"])) {
                this.empleados = [] as any;
                for (let item of _data["empleados"])
                    this.empleados!.push(EmpleadosRequestDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmpresasBase {
        data = typeof data === 'object' ? data : {};
        let result = new EmpresasBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["direccion"] = this.direccion;
        data["telefono"] = this.telefono;
        data["propietario"] = this.propietario;
        data["email"] = this.email;
        data["nit"] = this.nit;
        if (Array.isArray(this.empleados)) {
            data["empleados"] = [];
            for (let item of this.empleados)
                data["empleados"].push(item.toJSON());
        }
        return data;
    }

    clone(): EmpresasBase {
        const json = this.toJSON();
        let result = new EmpresasBase();
        result.init(json);
        return result;
    }
}

export interface IEmpresasBase {
    id?: number;
    nombre?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    propietario?: string | undefined;
    email?: string | undefined;
    nit?: string | undefined;
    empleados?: EmpleadosRequestDTO[] | undefined;
}

export class EmpresasUpdateRequestDTO implements IEmpresasUpdateRequestDTO {
    nombre?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    propietario?: string | undefined;
    email?: string | undefined;
    nit?: string | undefined;
    empleados?: EmpleadosRequestDTO[] | undefined;

    constructor(data?: IEmpresasUpdateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.direccion = _data["direccion"];
            this.telefono = _data["telefono"];
            this.propietario = _data["propietario"];
            this.email = _data["email"];
            this.nit = _data["nit"];
            if (Array.isArray(_data["empleados"])) {
                this.empleados = [] as any;
                for (let item of _data["empleados"])
                    this.empleados!.push(EmpleadosRequestDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmpresasUpdateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmpresasUpdateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["direccion"] = this.direccion;
        data["telefono"] = this.telefono;
        data["propietario"] = this.propietario;
        data["email"] = this.email;
        data["nit"] = this.nit;
        if (Array.isArray(this.empleados)) {
            data["empleados"] = [];
            for (let item of this.empleados)
                data["empleados"].push(item.toJSON());
        }
        return data;
    }

    clone(): EmpresasUpdateRequestDTO {
        const json = this.toJSON();
        let result = new EmpresasUpdateRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IEmpresasUpdateRequestDTO {
    nombre?: string | undefined;
    direccion?: string | undefined;
    telefono?: string | undefined;
    propietario?: string | undefined;
    email?: string | undefined;
    nit?: string | undefined;
    empleados?: EmpleadosRequestDTO[] | undefined;
}

export class FacturasProductosRequestDTO implements IFacturasProductosRequestDTO {

    facturaId?: number | undefined;
    productosId?: number | undefined;
    nombreProducto?: string | undefined;
    cantidad?: number;
    precio?: number;
    id?: number;

    constructor(data?: IFacturasProductosRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facturaId = _data["facturaId"];
            this.productosId = _data["productosId"];
            this.nombreProducto = _data["nombreProducto"];
            this.cantidad = _data["cantidad"];
            this.precio = _data["precio"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FacturasProductosRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FacturasProductosRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facturaId"] = this.facturaId;
        data["productosId"] = this.productosId;
        data["nombreProducto"] = this.nombreProducto;
        data["cantidad"] = this.cantidad;
        data["precio"] = this.precio;
        data["id"] = this.id;
        return data;
    }

    clone(): FacturasProductosRequestDTO {
        const json = this.toJSON();
        let result = new FacturasProductosRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IFacturasProductosRequestDTO {
    facturaId?: number | undefined;
    productosId?: number | undefined;
    nombreProducto?: string | undefined;
    cantidad?: number;
    precio?: number;
    id?: number;
}

export class FacturasBase implements IFacturasBase {
    id?: number;
    empleadoId?: number | undefined;
    clienteId?: number | undefined;
    nombreCliente?: string | undefined;
    estado?: string | undefined;
    total?: number;
    facturasProductos: any;

    constructor(data?: IFacturasBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.empleadoId = _data["empleadoId"];
            this.clienteId = _data["clienteId"];
            this.nombreCliente = _data["nombreCliente"];
            this.estado = _data["estado"];
            this.total = _data["total"];
            if (Array.isArray(_data["facturasProductos"])) {
                this.facturasProductos = [] as any;
                for (let item of _data["facturasProductos"])
                    this.facturasProductos!.push(FacturasProductosRequestDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FacturasBase {
        data = typeof data === 'object' ? data : {};
        let result = new FacturasBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["empleadoId"] = this.empleadoId;
        data["clienteId"] = this.clienteId;
        data["nombreCliente"] = this.nombreCliente;
        data["estado"] = this.estado;
        data["total"] = this.total;
        if (Array.isArray(this.facturasProductos)) {
            data["facturasProductos"] = [];
            for (let item of this.facturasProductos)
                data["facturasProductos"].push(item.toJSON());
        }
        return data;
    }

    clone(): FacturasBase {
        const json = this.toJSON();
        let result = new FacturasBase();
        result.init(json);
        return result;
    }
}

export interface IFacturasBase {
    id?: number;
    empleadoId?: number | undefined;
    clienteId?: number | undefined;
    nombreCliente?: string | undefined;
    estado?: string | undefined;
    total?: number;
    facturasProductos?: FacturasProductosRequestDTO[] | undefined;
}

export class FacturasRequestsDTO implements IFacturasRequestsDTO {
    empleadoId?: number | undefined;
    clienteId?: number | undefined;
    nombreCliente?: string | undefined;
    estado?: string | undefined;
    total?: number;
    facturasProductos?: FacturasProductosRequestDTO[] | undefined;
    id?: number;

    constructor(data?: IFacturasRequestsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.empleadoId = _data["empleadoId"];
            this.clienteId = _data["clienteId"];
            this.nombreCliente = _data["nombreCliente"];
            this.estado = _data["estado"];
            this.total = _data["total"];
            if (Array.isArray(_data["facturasProductos"])) {
                this.facturasProductos = [] as any;
                for (let item of _data["facturasProductos"])
                    this.facturasProductos!.push(FacturasProductosRequestDTO.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FacturasRequestsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FacturasRequestsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["empleadoId"] = this.empleadoId;
        data["clienteId"] = this.clienteId;
        data["nombreCliente"] = this.nombreCliente;
        data["estado"] = this.estado;
        data["total"] = this.total;
        if (Array.isArray(this.facturasProductos)) {
            data["facturasProductos"] = [];
            for (let item of this.facturasProductos)
                data["facturasProductos"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): FacturasRequestsDTO {
        const json = this.toJSON();
        let result = new FacturasRequestsDTO();
        result.init(json);
        return result;
    }
}

export interface IFacturasRequestsDTO {
    empleadoId?: number | undefined;
    clienteId?: number | undefined;
    nombreCliente?: string | undefined;
    estado?: string | undefined;
    total?: number;
    facturasProductos?: FacturasProductosRequestDTO[] | undefined;
    id?: number;
}

export class FacturasUpdateRequestDTO implements IFacturasUpdateRequestDTO {
    empleadoId?: number | undefined;
    clienteId?: number | undefined;
    nombreCliente?: string | undefined;
    estado?: string | undefined;
    total?: number;
    facturasProductos?: FacturasProductosRequestDTO[] | undefined;

    constructor(data?: IFacturasUpdateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.empleadoId = _data["empleadoId"];
            this.clienteId = _data["clienteId"];
            this.nombreCliente = _data["nombreCliente"];
            this.estado = _data["estado"];
            this.total = _data["total"];
            if (Array.isArray(_data["facturasProductos"])) {
                this.facturasProductos = [] as any;
                for (let item of _data["facturasProductos"])
                    this.facturasProductos!.push(FacturasProductosRequestDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FacturasUpdateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FacturasUpdateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["empleadoId"] = this.empleadoId;
        data["clienteId"] = this.clienteId;
        data["nombreCliente"] = this.nombreCliente;
        data["estado"] = this.estado;
        data["total"] = this.total;
        if (Array.isArray(this.facturasProductos)) {
            data["facturasProductos"] = [];
            for (let item of this.facturasProductos)
                data["facturasProductos"].push(item.toJSON());
        }
        return data;
    }

    clone(): FacturasUpdateRequestDTO {
        const json = this.toJSON();
        let result = new FacturasUpdateRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IFacturasUpdateRequestDTO {
    empleadoId?: number | undefined;
    clienteId?: number | undefined;
    nombreCliente?: string | undefined;
    estado?: string | undefined;
    total?: number;
    facturasProductos?: FacturasProductosRequestDTO[] | undefined;
}

export class FacturasProductosBase implements IFacturasProductosBase {
    facturaId?: number | undefined;
    productosId?: number | undefined;
    nombreProducto?: string | undefined;
    cantidad?: number;
    precio?: number;

    constructor(data?: IFacturasProductosBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facturaId = _data["facturaId"];
            this.productosId = _data["productosId"];
            this.nombreProducto = _data["nombreProducto"];
            this.cantidad = _data["cantidad"];
            this.precio = _data["precio"];
        }
    }

    static fromJS(data: any): FacturasProductosBase {
        data = typeof data === 'object' ? data : {};
        let result = new FacturasProductosBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facturaId"] = this.facturaId;
        data["productosId"] = this.productosId;
        data["nombreProducto"] = this.nombreProducto;
        data["cantidad"] = this.cantidad;
        data["precio"] = this.precio;
        return data;
    }

    clone(): FacturasProductosBase {
        const json = this.toJSON();
        let result = new FacturasProductosBase();
        result.init(json);
        return result;
    }
}

export interface IFacturasProductosBase {
    facturaId?: number | undefined;
    productosId?: number | undefined;
    nombreProducto?: string | undefined;
    cantidad?: number;
    precio?: number;
}

export class FacturasProductosUpdateRequestDTO implements IFacturasProductosUpdateRequestDTO {
    facturaId?: number | undefined;
    productosId?: number | undefined;
    nombreProducto?: string | undefined;
    cantidad?: number;
    precio?: number;

    constructor(data?: IFacturasProductosUpdateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facturaId = _data["facturaId"];
            this.productosId = _data["productosId"];
            this.nombreProducto = _data["nombreProducto"];
            this.cantidad = _data["cantidad"];
            this.precio = _data["precio"];
        }
    }

    static fromJS(data: any): FacturasProductosUpdateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FacturasProductosUpdateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facturaId"] = this.facturaId;
        data["productosId"] = this.productosId;
        data["nombreProducto"] = this.nombreProducto;
        data["cantidad"] = this.cantidad;
        data["precio"] = this.precio;
        return data;
    }

    clone(): FacturasProductosUpdateRequestDTO {
        const json = this.toJSON();
        let result = new FacturasProductosUpdateRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IFacturasProductosUpdateRequestDTO {
    facturaId?: number | undefined;
    productosId?: number | undefined;
    nombreProducto?: string | undefined;
    cantidad?: number;
    precio?: number;
}

export class ProductosRequestDTO implements IProductosRequestDTO {
    nombre?: string | undefined;
    cantidad?: number | undefined;
    precioCompra?: number | undefined;
    precioVenta?: number | undefined;
    precioActual?: number | undefined;
    precioMinimo?: number | undefined;
    precioMaximo?: number | undefined;
    fechaVencimiento?: Date | undefined;
    categoriaId?: number | undefined;
    id?: number | undefined;

    constructor(data?: IProductosRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.cantidad = _data["cantidad"];
            this.precioCompra = _data["precioCompra"];
            this.precioVenta = _data["precioVenta"];
            this.precioActual = _data["precioActual"];
            this.precioMinimo = _data["precioMinimo"];
            this.precioMaximo = _data["precioMaximo"];
            this.fechaVencimiento = _data["fechaVencimiento"] ? new Date(_data["fechaVencimiento"].toString()) : <any>undefined;
            this.categoriaId = _data["categoriaId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductosRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductosRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["cantidad"] = this.cantidad;
        data["precioCompra"] = this.precioCompra;
        data["precioVenta"] = this.precioVenta;
        data["precioActual"] = this.precioActual;
        data["precioMinimo"] = this.precioMinimo;
        data["precioMaximo"] = this.precioMaximo;
        data["fechaVencimiento"] = this.fechaVencimiento ? this.fechaVencimiento.toISOString() : <any>undefined;
        data["categoriaId"] = this.categoriaId;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductosRequestDTO {
        const json = this.toJSON();
        let result = new ProductosRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IProductosRequestDTO {
    nombre?: string | undefined;
    cantidad?: number | undefined;
    precioCompra?: number | undefined;
    precioVenta?: number | undefined;
    precioActual?: number | undefined;
    precioMinimo?: number | undefined;
    precioMaximo?: number | undefined;
    fechaVencimiento?: Date | undefined;
    categoriaId?: number | undefined;
    id?: number | undefined;
}

export class ProductosBase implements IProductosBase {
    id?: number;
    nombre?: string | undefined;
    cantidad?: number | undefined;
    precioCompra?: number | undefined;
    precioVenta?: number | undefined;
    precioActual?: number | undefined;
    precioMinimo?: number | undefined;
    precioMaximo?: number | undefined;
    fechaVencimiento?: Date | undefined;
    categoriaId?: number | undefined;

    constructor(data?: IProductosBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nombre = _data["nombre"];
            this.cantidad = _data["cantidad"];
            this.precioCompra = _data["precioCompra"];
            this.precioVenta = _data["precioVenta"];
            this.precioActual = _data["precioActual"];
            this.precioMinimo = _data["precioMinimo"];
            this.precioMaximo = _data["precioMaximo"];
            this.fechaVencimiento = _data["fechaVencimiento"] ? new Date(_data["fechaVencimiento"].toString()) : <any>undefined;
            this.categoriaId = _data["categoriaId"];
        }
    }

    static fromJS(data: any): ProductosBase {
        data = typeof data === 'object' ? data : {};
        let result = new ProductosBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["cantidad"] = this.cantidad;
        data["precioCompra"] = this.precioCompra;
        data["precioVenta"] = this.precioVenta;
        data["precioActual"] = this.precioActual;
        data["precioMinimo"] = this.precioMinimo;
        data["precioMaximo"] = this.precioMaximo;
        data["fechaVencimiento"] = this.fechaVencimiento ? this.fechaVencimiento.toISOString() : <any>undefined;
        data["categoriaId"] = this.categoriaId;
        return data;
    }

    clone(): ProductosBase {
        const json = this.toJSON();
        let result = new ProductosBase();
        result.init(json);
        return result;
    }
}

export interface IProductosBase {
    id?: number;
    nombre?: string | undefined;
    cantidad?: number | undefined;
    precioCompra?: number | undefined;
    precioVenta?: number | undefined;
    precioActual?: number | undefined;
    precioMinimo?: number | undefined;
    precioMaximo?: number | undefined;
    fechaVencimiento?: Date | undefined;
    categoriaId?: number | undefined;
}

export class ProductosUpdateRequestDTO implements IProductosUpdateRequestDTO {
    id?: number;
    nombre?: string | undefined;
    cantidad?: number | undefined;
    precioCompra?: number | undefined;
    precioVenta?: number | undefined;
    precioActual?: number | undefined;
    precioMinimo?: number | undefined;
    precioMaximo?: number | undefined;
    fechaVencimiento?: Date | undefined;
    categoriaId?: number | undefined;

    constructor(data?: IProductosUpdateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nombre = _data["nombre"];
            this.cantidad = _data["cantidad"];
            this.precioCompra = _data["precioCompra"];
            this.precioVenta = _data["precioVenta"];
            this.precioActual = _data["precioActual"];
            this.precioMinimo = _data["precioMinimo"];
            this.precioMaximo = _data["precioMaximo"];
            this.fechaVencimiento = _data["fechaVencimiento"] ? new Date(_data["fechaVencimiento"].toString()) : <any>undefined;
            this.categoriaId = _data["categoriaId"];
        }
    }

    static fromJS(data: any): ProductosUpdateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductosUpdateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["cantidad"] = this.cantidad;
        data["precioCompra"] = this.precioCompra;
        data["precioVenta"] = this.precioVenta;
        data["precioActual"] = this.precioActual;
        data["precioMinimo"] = this.precioMinimo;
        data["precioMaximo"] = this.precioMaximo;
        data["fechaVencimiento"] = this.fechaVencimiento ? this.fechaVencimiento.toISOString() : <any>undefined;
        data["categoriaId"] = this.categoriaId;
        return data;
    }

    clone(): ProductosUpdateRequestDTO {
        const json = this.toJSON();
        let result = new ProductosUpdateRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IProductosUpdateRequestDTO {
    id?: number;
    nombre?: string | undefined;
    cantidad?: number | undefined;
    precioCompra?: number | undefined;
    precioVenta?: number | undefined;
    precioActual?: number | undefined;
    precioMinimo?: number | undefined;
    precioMaximo?: number | undefined;
    fechaVencimiento?: Date | undefined;
    categoriaId?: number | undefined;
}

export class TipoClientesRequestDTO implements ITipoClientesRequestDTO {
    tipoCliente?: string | undefined;
    clienteId?: number;
    id?: number;

    constructor(data?: ITipoClientesRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tipoCliente = _data["tipoCliente"];
            this.clienteId = _data["clienteId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TipoClientesRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TipoClientesRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tipoCliente"] = this.tipoCliente;
        data["clienteId"] = this.clienteId;
        data["id"] = this.id;
        return data;
    }

    clone(): TipoClientesRequestDTO {
        const json = this.toJSON();
        let result = new TipoClientesRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ITipoClientesRequestDTO {
    tipoCliente?: string | undefined;
    clienteId?: number;
    id?: number;
}

export class TipoClientesBase implements ITipoClientesBase {
    tipoCliente?: string | undefined;
    clienteId?: number;

    constructor(data?: ITipoClientesBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tipoCliente = _data["tipoCliente"];
            this.clienteId = _data["clienteId"];
        }
    }

    static fromJS(data: any): TipoClientesBase {
        data = typeof data === 'object' ? data : {};
        let result = new TipoClientesBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tipoCliente"] = this.tipoCliente;
        data["clienteId"] = this.clienteId;
        return data;
    }

    clone(): TipoClientesBase {
        const json = this.toJSON();
        let result = new TipoClientesBase();
        result.init(json);
        return result;
    }
}

export interface ITipoClientesBase {
    tipoCliente?: string | undefined;
    clienteId?: number;
}

export class TipoClientesUpdateRequestDTO implements ITipoClientesUpdateRequestDTO {
    tipoCliente?: string | undefined;
    clienteId?: number;

    constructor(data?: ITipoClientesUpdateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tipoCliente = _data["tipoCliente"];
            this.clienteId = _data["clienteId"];
        }
    }

    static fromJS(data: any): TipoClientesUpdateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TipoClientesUpdateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tipoCliente"] = this.tipoCliente;
        data["clienteId"] = this.clienteId;
        return data;
    }

    clone(): TipoClientesUpdateRequestDTO {
        const json = this.toJSON();
        let result = new TipoClientesUpdateRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ITipoClientesUpdateRequestDTO {
    tipoCliente?: string | undefined;
    clienteId?: number;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }

    clone(): WeatherForecast {
        const json = this.toJSON();
        let result = new WeatherForecast();
        result.init(json);
        return result;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
